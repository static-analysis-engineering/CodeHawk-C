#!/usr/bin/env python3
# ------------------------------------------------------------------------------
# CodeHawk C Analyzer
# Author: Henny Sipma
# ------------------------------------------------------------------------------
# The MIT License (MIT)
#
# Copyright (c) 2023-2024  Aarno Labs, LLC
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# ------------------------------------------------------------------------------
"""Command-line interface to the CodeHawk C Analyzer.

The CodeHawk C Analyzer is a sound static analysis tool that attempts to prove
the absence of undefined behavior. It does so by generating a comprehensive set
of proof obligations that capture all conditions that can lead to undefined
behavior and attempts to prove that the negation of those conditions is valid,
that is true for all inputs. The status of these proof obligations can then
be inspected via various reports.

The CodeHawk-C analyzer calls two executables from the codehawk repository
that perform the parsing and analysis. To check if these two executables are
available, you can run:

- chkc info

Analysis commands are provided for two distinct ways of analysis:

- chkc c-file .... analyzes a single source file (that can be parsed by gcc)
- chkc c-project ...
             analyzes a project of multiple files that comes with a Makefile

Run the respective option for more information on either one.
"""

import argparse
import json
import os
import subprocess
import sys

from typing import NoReturn


from chc.app.CHVersion import chcversion

import chc.cmdline.c_file.cfileutil as C
import chc.cmdline.juliet.julietutil as J
import chc.cmdline.kendra.kendrautil as K
import chc.reporting.DictionaryTables as DT

from chc.util.Config import Config
import chc.util.loggingutil as UL


def showversion(args: argparse.Namespace) -> NoReturn:
    print("CodeHawk-C Analyzer (python) Version: " + chcversion)
    config = Config()
    canalyzer = config.canalyzer
    cmd = [canalyzer, "version"]
    subprocess.call(cmd, stderr=subprocess.STDOUT)
    exit(0)


def showinfo(args: argparse.Namespace) -> NoReturn:
    print(str(Config()))
    exit(0)


def cfilecommand(args: argparse.Namespace) -> NoReturn:
    descr =  """
The chkc c-file set of commands is used to analyze a single file.

The regular sequence of commands is:

> chkc c-file parse <cfilename>.c

This command will call gcc to preprocess the file and produce an .i file.
Then the CodeHawk/CIL parser is called to convert the preprocessed file into
OCaml data structures for further analysis. The data structures are stored
in xml_format in (by default) the directory <cfilename>.cch .

The command

> chkc c-file analyze <cfilename>.c

loads the data structures and generates proof obligations, and then generates
invariants, using abstract interpretation, to be used to discharge the proof
obligations. This is repeated (by default) 5 times. The analysis results are
stored in xml-form in the same directory.

The command

> chkc c-file report <cfilename>.c

produces a (text or json) report of the proof obligations proven and those that
could not be proven, with some additional information why they could not be
proven that may be helpful in either fixing the code or providing additional
assumptions on the code.
    """
    print(descr)
    exit(0)


def julietcommand(args: argparse.Namespace) -> NoReturn:
    descr = """
The chkc juliet set of commands is used to analyze the juliet test suite cases
provided in

https://github.com/static-analysis-engineering/CodeHawk-C-Targets-Juliet
"""
    print(descr)
    exit(0)

def parse() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=__doc__,
        epilog="See for more information ...")
    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        exit(0)
    subparsers = parser.add_subparsers(title="subcommands")
    parser_info = subparsers.add_parser("info")
    parser_info.set_defaults(func=showinfo)

    parser_version = subparsers.add_parser("version")
    parser_version.set_defaults(func=showversion)

    # --------------------------------------------------------------- kendra ---
    kendracmd = subparsers.add_parser("kendra")
    kendraparsers = kendracmd.add_subparsers(title="show options")

    # --- kendra list
    kendralist = kendraparsers.add_parser("list")
    kendralist.set_defaults(func=K.kendra_list)

    # --- kendra show-set
    kendrashowset = kendraparsers.add_parser("show-set")
    kendrashowset.add_argument(
        "testset", help="name of test directory (e.g., id115Q)")
    kendrashowset.set_defaults(func=K.kendra_show_set)

    # --- kendra clean-set
    kendracleanset = kendraparsers.add_parser("clean-set")
    kendracleanset.add_argument(
        "testset", help="name of test directory (e.g., id115Q)")
    kendracleanset.set_defaults(func=K.kendra_clean_set)

    # --- kendra test-set
    kendratestset = kendraparsers.add_parser("test-set")
    kendratestset.add_argument(
        "testset", help="name of test directory (e.g., id115Q)")
    kendratestset.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="WARNING",
        help="activate logging with given level (default to stderr)")
    kendratestset.add_argument(
        "--logfilename",
        help="name of file to write log messages (default is <testset>_log.txt)")
    kendratestset.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")
    kendratestset.add_argument(
        "--verbose", "-v", help="print verbose output", action="store_true")
    kendratestset.set_defaults(func=K.kendra_test_set)

    # --- kendra test-sets
    kendratestsets = kendraparsers.add_parser("test-sets")
    kendratestsets.add_argument(
        "--verbose", "-v", help="print_verbose_output", action="store_true")
    kendratestsets.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="WARNING",
        help="activate logging with given level (default to stderr)")
    kendratestsets.add_argument(
        "--logfilename",
        help="name of file to write log messages (default is <testset>_log.txt)")
    kendratestsets.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")

    kendratestsets.set_defaults(func=K.kendra_test_sets)

    # --- kendra dashboard
    kendradashboard = kendraparsers.add_parser("dashboard")
    kendradashboard.set_defaults(func=K.kendra_dashboard)

    # --- kendra report-file
    kendrareportfile = kendraparsers.add_parser("report-file")
    kendrareportfile.add_argument(
        "cfilename", help="name of kendra c file (e.g., id115.c)")
    kendrareportfile.add_argument(
        "--show_invariants",
        help="show invariants at each line in the source code",
        action="store_true")
    kendrareportfile.set_defaults(func=K.kendra_report_file)

    # --- kendra show-file-table
    kendrashowfiletable = kendraparsers.add_parser("show-file-table")
    kendrashowfiletable.add_argument(
        "cfilename", help="name of kendra c file (e.g., id115.c)")
    kendrashowfiletable.add_argument(
        "tablename",
        help="name of table",
        choices = DT.file_table_list())
    kendrashowfiletable.set_defaults(func=K.kendra_show_file_table)

    # --- kendra show-function-table
    kendrashowfunctiontable = kendraparsers.add_parser("show-function-table")
    kendrashowfunctiontable.add_argument(
        "cfilename", help="name of kendra c file (e.g., id115.c)")
    kendrashowfunctiontable.add_argument(
        "functionname", help="name of function in c file (e.g., main)")
    kendrashowfunctiontable.add_argument(
        "tablename",
        help="name of table",
        choices = DT.function_table_list())
    kendrashowfunctiontable.set_defaults(func=K.kendra_show_function_table)

    # --------------------------------------------------------------- juliet ---

    julietcmd = subparsers.add_parser("juliet")
    julietcmd.set_defaults(func=julietcommand)
    julietparsers = julietcmd.add_subparsers(title="show options")

    # --- check-config
    julietconfig = julietparsers.add_parser("check-config")
    julietconfig.set_defaults(func=J.juliet_check_config)

    # --- list
    julietlist = julietparsers.add_parser("list")
    julietlist.add_argument("--cwe", help="only list tests for CWE")
    julietlist.set_defaults(func=J.juliet_list)

    # --- convert
    julietconvert = julietparsers.add_parser("convert")
    julietconvert.add_argument("cwe", help="name of cwe, e.g., CWE121")
    julietconvert.add_argument(
        "test", help="name of test case, e.g., CWE129_large")
    julietconvert.add_argument(
        "targetpath", help="directory in which to store converted set")
    julietconvert.set_defaults(func=J.juliet_convert)

    # --- analyze
    julietanalyze = julietparsers.add_parser("analyze")
    julietanalyze.add_argument("cwe", help="name of cwe, e.g., CWE121")
    julietanalyze.add_argument(
        "test", help="name of test case, e.g., CWE129_large")
    julietanalyze.add_argument(
        "--maxprocesses",
        help="number of files to process in parallel",
        type=int,
        default=1)
    julietanalyze.add_argument(
        "--analysisrounds",
        help="number of times to generate supporting proof obligations",
        type=int,
        default=5)
    julietanalyze.add_argument(
        "--wordsize",
        help="architecture word size in bits",
        type=int,
        default=64)
    julietanalyze.add_argument(
        "--contractpath",
        help="path to save the contracts file",
        default=None)
    julietanalyze.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="show output from ocaml analyzer")
    julietanalyze.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="WARNING",
        help="activate logging with given level (default to stderr)")
    julietanalyze.add_argument(
        "--logfilename",
        help="name of file to write log messages (default is <testset>_log.txt)")
    julietanalyze.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")

    julietanalyze.set_defaults(func=J.juliet_analyze)

    # --- report
    julietreport = julietparsers.add_parser("report")
    julietreport.add_argument("cwe", help="name of cwe, e.g., CWE121")
    julietreport.add_argument(
        "test", help="name of test case, e.g., CWE129_large")
    julietreport.set_defaults(func=J.juliet_report)

    # --- report-file
    julietreportfile = julietparsers.add_parser("report-file")
    julietreportfile.add_argument("cwe", help="name of cwe, e.g., CWE121")
    julietreportfile.add_argument(
        "test", help="name of test case, e.g., CWE129_large")
    julietreportfile.add_argument("filename", help="name of c file, e.g., x01.c")
    julietreportfile.set_defaults(func=J.juliet_report_file)

    # --- score
    julietscore = julietparsers.add_parser("score")
    julietscore.add_argument("cwe", help="name of cwe, e.g., CWE121")
    julietscore.add_argument(
        "test", help="name of test case, e.g., CWE129_large")
    julietscore.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="WARNING",
        help="activate logging with given level (default to stderr)")
    julietscore.add_argument(
        "--logfilename",
        help="name of file to write log messages (default is <testset>_log.txt)")
    julietscore.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")

    julietscore.set_defaults(func=J.juliet_score)

    # --------------------------------------------------------------- c-file ---
    cfilecmd = subparsers.add_parser("c-file")
    cfilecmd.set_defaults(func=cfilecommand)
    cfileparsers = cfilecmd.add_subparsers(title="show options")

    # --- parse
    cfileparse = cfileparsers.add_parser(
        "parse",
        usage="""
        Call with the name of c file to be parsed.

        Example:
        > chkc c-file parse myfile.c

        The parse results will be saved in the subdirectory myfile.cch.

        To save the parse results in a different directory, say myresults,
        call with the additional argument --tgtpath:

        > chkc c-file parse myfile --tgtpath myresults

        Note: the directory passed to tgtpath must exist
        """)
    cfileparse.add_argument(
        "filename",
        help="name of file to parse ((<cpath/>)<cfilename>)")
    cfileparse.add_argument(
        "--tgtpath",
        help=("directory in which to store the analysis artifacts "
              + "(default: <cpath>)"))
    cfileparse.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with given level (default to stderr)")
    cfileparse.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    cfileparse.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")

    cfileparse.set_defaults(func=C.cfile_parse_file)

    # --- analyze
    cfileanalyze = cfileparsers.add_parser("analyze")
    cfileanalyze.add_argument(
        "filename",
        help="name of file to analyze ((<cpath/>)<cfilename>)")
    cfileanalyze.add_argument(
        "--tgtpath",
        help="directory in which to store the analysis artifacts "
        + "(default: <cpath>)")
    cfileanalyze.add_argument(
        "--wordsize",
        type=int,
        default=32,
        help="architecture wordsize in bits (16, 32, or 64)")
    cfileanalyze.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="print intermediate results")
    cfileanalyze.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with given level (default to stderr)")
    cfileanalyze.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    cfileanalyze.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")
    cfileanalyze.set_defaults(func=C.cfile_analyze_file)

    # --- report
    cfilereport = cfileparsers.add_parser("report")
    cfilereport.add_argument(
        "filename",
        help="name of file to analyze ((<cpath/>)<cfilename>)")
    cfilereport.add_argument(
        "--tgtpath",
        help="directory that holds the analysis results")
    cfilereport.add_argument(
        "--showcode",
        action="store_true",
        help="show proof obligations on code for entire file")
    cfilereport.add_argument(
        "--functions",
        nargs="*",
        help="restrict output to function names listed (defualt: all)")
    cfilereport.add_argument(
        "--open",
        action="store_true",
        help="only show open proof obligations")
    cfilereport.add_argument(
        "--json",
        action="store_true",
        help="output results in json format")
    cfilereport.add_argument(
        "--output", "-o",
        help="name of outputfile (without extension)")
    cfilereport.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with given level (default to stderr)")
    cfilereport.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    cfilereport.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")

    cfilereport.set_defaults(func=C.cfile_report_file)

    # --- investigate
    cfileinvestigate = cfileparsers.add_parser("investigate")
    cfileinvestigate.add_argument(
        "filename",
        help="name of file to analyze ((<cpath/>)<cfilename>)")
    cfileinvestigate.add_argument(
        "--tgtpath",
        help="directory that holds the analysis results")
    cfileinvestigate.add_argument(
        "--predicates",
        nargs="*",
        help="names of predicates of interest, e.g., not-null (default: all")
    cfileinvestigate.add_argument(
        "--referrals",
        action="store_true",
        help="show diagnostics with a domain referral")
    cfileinvestigate.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with given level (default to stderr)")
    cfileinvestigate.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    cfileinvestigate.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")
    cfileinvestigate.set_defaults(func=C.cfile_investigate_file)

    # --- test libc summary
    cfiletestlibc = cfileparsers.add_parser("test-libc-summary")
    cfiletestlibc.add_argument(
        "header", help="name of header file, e.g., time")
    cfiletestlibc.add_argument(
        "function", help="name of function, e.g., localtime")
    cfiletestlibc.add_argument(
        "--showcode",
        action="store_true",
        help="show proof obligations and results on code")
    cfiletestlibc.add_argument(
        "--open",
        action="store_true",
        help="only show open proof obligations on code")
    cfiletestlibc.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with given level (default to stderr)")
    cfiletestlibc.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    cfiletestlibc.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")
    cfiletestlibc.set_defaults(func=C.cfile_testlibc_summary)

    args = parser.parse_args()
    return args


if __name__ == "__main__":

    args = parse()
    args.func(args)
