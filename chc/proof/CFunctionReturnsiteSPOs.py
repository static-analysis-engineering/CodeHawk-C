# ------------------------------------------------------------------------------
# CodeHawk C Analyzer
# Author: Henny Sipma
# ------------------------------------------------------------------------------
# The MIT License (MIT)
#
# Copyright (c) 2017-2020 Kestrel Technology LLC
# Copyright (c) 2020-2022 Henny B. Sipma
# Copyright (c) 2023-2024 Aarno Labs LLC
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# ------------------------------------------------------------------------------
"""All supporting proof obligations associated with a single return site."""

import xml.etree.ElementTree as ET

from typing import Callable, Dict, List, Optional, TYPE_CHECKING

import chc.util.xmlutil as UX
import chc.proof.CFunctionPO as PO

from chc.app.CLocation import CLocation

from chc.proof.CFunctionReturnsiteSPO import CFunctionReturnsiteSPO
from chc.proof.CProofDependencies import CProofDependencies
from chc.proof.CProofDiagnostic import CProofDiagnostic

import chc.util.fileutil as UF

if TYPE_CHECKING:
    from chc.app.CContext import ProgramContext, CfgContext
    from chc.app.CContextDictionary import CContextDictionary
    from chc.app.CFile import CFile
    from chc.app.CFunction import CFunction
    from chc.proof.CFunctionProofs import CFunctionProofs
    from chc.proof.CFunctionSPOs import CFunctionSPOs
    from chc.proof.CFunPODictionary import CFunPODictionary


po_status = {"g": "safe", "o": "open", "r": "violation", "x": "dead-code"}


class CFunctionReturnsiteSPOs:
    """Represents the supporting proof obligations associated with a return site.

    All return site supporting proof obligations are generated by the analyzer.
    """

    def __init__(self, cproofs: "CFunctionProofs", xnode: ET.Element) -> None:
        self._cproofs = cproofs
        self.xnode = xnode
        self.returnexp = self.cfile.declarations.dictionary.read_xml_exp_opt(xnode)

        # pcid -> CFunctionReturnsiteSPO list
        self._spos: Optional[Dict[int, List[CFunctionReturnsiteSPO]]] = None

    @property
    def cproofs(self) -> "CFunctionProofs":
        return self._cproofs

    @property
    def cfun(self) -> "CFunction":
        return self.cproofs.cfun

    @property
    def cfile(self) -> "CFile":
        return self.cproofs.cfile

    @property
    def podictionary(self) -> "CFunPODictionary":
        return self.cfun.podictionary

    @property
    def contextdictionary(self) -> "CContextDictionary":
        return self.cfile.contextdictionary

    @property
    def spos(self) -> Dict[int, List[CFunctionReturnsiteSPO]]:
        if self._spos is None:
            self._spos = {}
            xgnode = self.xnode.find("post-guarantees")
            if xgnode is not None:
                for p in xgnode.findall("pc"):
                    xipc = p.get("iipc")
                    if xipc is None:
                        raise UF.CHCError("Missing iipc in returnsite spo")
                    ipc = int(xipc)
                    self._spos[ipc] = []
                    for xpo in p.findall("po"):
                        spotype = self.podictionary.read_xml_spo_type(xpo)
                        deps = CProofDependencies(self.cproofs, xpo)
                        status = po_status[xpo.get("s", "o")]
                        xexpl = xpo.find("e")
                        expl = None if xexpl is None else xexpl.get("txt")
                        diagnostic = CProofDiagnostic(xpo.find("d"))
                        self._spos[ipc].append(
                            CFunctionReturnsiteSPO(
                                self, spotype, status, deps, expl, diagnostic))
        return self._spos

    @property
    def context(self) -> "ProgramContext":
        return self.contextdictionary.read_xml_context(self.xnode)

    @property
    def location(self) -> "CLocation":
        return self.cfile.declarations.read_xml_location(self.xnode)

    @property
    def line(self) -> int:
        return self.location.line

    @property
    def cfgcontext(self) -> "CfgContext":
        return self.context.cfg_context

    def get_spo(self, id: int) -> CFunctionReturnsiteSPO:
        if self.has_spo(id):
            for pcid in self.spos:
                for spo in self.spos[pcid]:
                    if spo.po_index == id:
                        return spo
        raise UF.CHCError("Returnsite spo with id " + str(id) + " not found")

    def has_spo(self, id: int) -> bool:
        for pcid in self.spos:
            for spo in self.spos[pcid]:
                if spo.po_index == id:
                    return True
        return False

    def iter(self, f: Callable[[CFunctionReturnsiteSPO], None]) -> None:
        for id in self.spos:
            for spo in self.spos[id]:
                f(spo)

    def write_xml(self, cnode: ET.Element) -> None:
        self.cfile.declarations.write_xml_location(cnode, self.location)
        self.contextdictionary.write_xml_context(cnode, self.context)
        self.cfile.declarations.dictionary.write_xml_exp_opt(cnode, self.returnexp)
        oonode = ET.Element("post-guarantees")
        for pcid in self.spos:
            pcnode = ET.Element("pc")
            pcnode.set("iipc", str(pcid))
            for spo in self.spos[pcid]:
                onode = ET.Element("po")
                spo.write_xml(onode)
                pcnode.append(onode)
            oonode.append(pcnode)
        cnode.extend([oonode])
